package com.guessinggame.guessinggame.services;import com.guessinggame.guessinggame.entity.Game;import com.guessinggame.guessinggame.entity.User;import com.guessinggame.guessinggame.model.Attempt;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import java.text.DecimalFormat;import java.util.*;import java.util.stream.Collectors;@Servicepublic class GameUtils {    private List<Integer> foundedGuessNumber = new ArrayList<>();    private List<String> log;    private List<String> logDetails;    private Set<Integer> generatedNumber;    private final Random random = new Random();    private int triesCount;    private boolean isPlay;    @Autowired    private UserService userService;    public void startGame(Game game) {        generatedNumber = new LinkedHashSet<>();        log = new ArrayList<>();        isPlay = true;        triesCount = 8;        generateRandomNumber();        System.out.println("Random number is: " + getGeneratedNumber());    }    public void isContinuumToPlay(Game game) {        decreaseTriesCount();        if(triesCount == 0) {            isPlay = false;            game.setLost(true);        }    }    public void decreaseTriesCount() {        logDetails = new ArrayList<>();        setTriesCount(triesCount - 1);    }    public int getNumberOfMatchingNumberExactInPlace(Attempt attempt, Game game) {        logDetails.add(attempt.toString());        int[] lastGuess = attempt.getLastGuess();        int i = 0;        int numberOfMatchingNumberExactInPlace = 0;        for (Integer generatedNumber : getGeneratedNumber()) {            if (generatedNumber == lastGuess[i]) {                numberOfMatchingNumberExactInPlace++;            }            i++;        }        if (numberOfMatchingNumberExactInPlace == 4) {            game.setWin(true);            isPlay= false;            game.getUser().setGamesWin(game.getUser().getGamesWin()+1);            game.setWin(true);            userService.save(game.getUser());        }        logDetails.add(" P: " + numberOfMatchingNumberExactInPlace + ";");        return numberOfMatchingNumberExactInPlace;    }    public int getNumberOfMatchingDigitsNotInPlace(Attempt attempt, Game game) {        int numberOfMatchingDigitsNotInPlace = 0;        int[] lastGuess = attempt.getLastGuess();        for (int i = 0; i < lastGuess.length; i++) {            if (getGeneratedNumber().contains(lastGuess[i])) {                if (!foundedGuessNumber.contains(lastGuess[i])) {                    foundedGuessNumber.add(lastGuess[i]);                    numberOfMatchingDigitsNotInPlace++;                }            }        }        logDetails.add(" M: " + numberOfMatchingDigitsNotInPlace + ";");        return numberOfMatchingDigitsNotInPlace;    }    public List<String> getLog() {        createLog(logDetails);        return log;    }    private void createLog(List<String> logDetails) {        log.add(0, logDetails.get(0) + logDetails.get(1) + logDetails.get(2));    }    public void generateRandomNumber() {        while (generatedNumber.size() != 4) {            int randomNumber = random.nextInt(10);            generatedNumber.add(randomNumber);        }    }    public Map<String, String> getLeaderUsers(String minPlayedGames) {        List<User> users = null;        if(minPlayedGames != null && !minPlayedGames.isBlank()) {            users = userService.findAllByMinPlayedGAndGamesWin(Integer.parseInt(minPlayedGames));            System.out.println("TEST ALL USERS: " + users);        } else {            users = userService.findAll();        }        return calculateScore(users);    }    private Map<String, String> calculateScore(List<User> users) {        Map<String, Double> userScore = new TreeMap<>();        for(User user : users) {            System.out.println("Test: " + user.getGamesWin() / (double)user.getPlayedGames());            userScore.put(user.getUsername(), user.getGamesWin() / (double)user.getPlayedGames());        }        return sortScore(userScore);    }    private Map<String, String> sortScore(Map<String,Double> notSortedUsers) {        DecimalFormat decimalFormat = new DecimalFormat("#0.000");        List<Map.Entry<String, Double>> list =                new LinkedList<Map.Entry<String, Double>>(notSortedUsers.entrySet());        Collections.sort(list, new Comparator<Map.Entry<String, Double>>() {            public int compare(Map.Entry<String, Double> o1,                               Map.Entry<String, Double> o2) {                return (o1.getValue()).compareTo(o2.getValue());            }        });        Map<String, String> sortedMap = new LinkedHashMap<String, String>();        for (Map.Entry<String, Double> entry : list) {            sortedMap.put(entry.getKey(), decimalFormat.format(entry.getValue()));        }        return sortedMap.entrySet().stream().sorted(Collections.reverseOrder(Map.Entry.comparingByValue()))                .collect(Collectors.toMap(                        Map.Entry::getKey,                        Map.Entry::getValue,                        (oldValue, newValue) -> oldValue, LinkedHashMap::new                ));    }    public boolean isDigit(String value) {        if(!value.isEmpty() && value.matches("[0-9]+")) {            return true;        }        return false;    }    public Set<Integer> getGeneratedNumber() {        return generatedNumber;    }    public void setGeneratedNumber(Set<Integer> generatedNumber) {        this.generatedNumber = generatedNumber;    }    public int getTriesCount() {        return triesCount;    }    public void setTriesCount(int triesCount) {        this.triesCount = triesCount;    }    public boolean isPlay() {        return isPlay;    }    public void setPlay(boolean play) {        isPlay = play;    }}